/*
* GameController.c
*
* Created: 9/4/2019 7:22:14 PM
* Author : User
*/

//setting ATmega's clock frequency to 8MHz
#ifndef F_CPU
#define F_CPU 8000000UL
#endif


#define D0 eS_PORTD0
#define D1 eS_PORTD1
#define D2 eS_PORTD2
#define D3 eS_PORTD3
#define D4 eS_PORTD4
#define D5 eS_PORTD5
#define D6 eS_PORTD6
#define D7 eS_PORTD7
#define RS eS_PORTC6
#define EN eS_PORTC7


#include <avr/io.h>
#include <util/delay.h>
#include <avr/interrupt.h>
#include <stdlib.h>
#include <string.h>
#include "lcd.h"
#include "rtc.h"


int life = 5;		//initial lives
int score = 1000;	//initial score

uint16_t adc_output = 0;		//ADC output for the LDRs
float actual_voltage = 0;		//voltage of the LDRs
int analog_ir_sensor_value;		//voltage of the IR sensors

int currentOff;		//index of the laser that is currently off
int wait;			//loop variable to set the time duration for laser on-off
int start = 0;		//0 if game hasn't started yet (object not detected at start point), 1 otherwise



int output[5] = {	//PORTB values for turning on the right lasers based on currentOff
	0b01111000,
	0b10111000,
	0b11011000,
	0b11101000,
	0b11110000
};

int admux[5] = {	//ADMUX values for selecting ADC channels for the LDRs
	0b01100111,
	0b01100110,
	0b01100101,
	0b01100100,
	0b01100011
};

rtc_t rtc;	//RTC time variable

void RTC_values();	//setting the value of the rtc variable
void adc_init();	//ADC initialization for IR sensors
int read_adc_channel(unsigned char channel);	//ADC reading for IR sensors
void display_results();		//LCD display to show results when game is over

/*
This is the Interrupt Service Routine for INT2 which is generated by an output 
from the receiver ATmega when the player object remains still for too long.
*/
ISR(INT2_vect)		
{
	score -= 100;
	_delay_ms(50);
}



int main(void)
{
	DDRB = 0b11111010;	//PB7-PB3 output for laser beams and PB1 output for buzzer
	PORTB = 0x00;		//initially all lasers are off
	
	RTC_values();
	
	//LCD initialization
	LCD_SetUp(PC_6,P_NC,PC_7,P_NC,P_NC,P_NC,P_NC,PD_4,PD_5,PD_6,PD_7);
	LCD_Init(2,16);
	//RTC initialization
	RTC_Init();
	
	//configuring registers for INT2
	GICR = (1 << INT2);
	MCUCSR |= (1 << ISC2);
	
	currentOff = 4;
	wait = 0;
	

	while (1)
	{
		if(start == 0)		//Game hasn't started yet
		{
			adc_init();
			/*Reading analog IR sensor value from Start IR*/
			analog_ir_sensor_value=read_adc_channel(0);		//Start IR is connected to ADC channel 0
			analog_ir_sensor_value = analog_ir_sensor_value/256;	//to work with a small range of voltages
			
			if(analog_ir_sensor_value < 2)
			{
				//object detected at start point
				start = 1;				//start game
				PORTB = 0b11111000;		//turn on all the lasers
				RTC_SetDateTime(&rtc);	//start RTC
				sei();					//enable global interrupt system
				continue;
			}
			LCD_Clear();
			LCD_GoToLine(0);
			LCD_Printf("LASER MAZE");
			_delay_ms(10);
		}
		else if(start == 1)		//Game ongoing
		{
			adc_init();
			/*Reading analog IR sensor value from End IR*/
			analog_ir_sensor_value=read_adc_channel(2);		//End IR is connected to ADC channel 2
			analog_ir_sensor_value = analog_ir_sensor_value/256;
			
			if(analog_ir_sensor_value < 2)
			{
				//object detected at end point
				score += 500;
				display_results();
				break;
			}
			
			//clearing ADC registers for the LDRs
			ADCSRA = 0x00;
			ADMUX = 0x00;
			
			PORTB = PORTB & 0xFD;	//buzzer off
			
			if(wait == 10)		//time to turn off the next laser
			{
				wait = 0;
				currentOff = (currentOff + 1) % 5;
				PORTB = output[currentOff];
				_delay_ms(10);
			}
			
			for(int i = 0; i < 5; i++)		//LDR voltage checking for laser cuts
			{
				//ADC initialization [needs to be done for each of the 5 LDRs]
				ADCSRA = 0b10000111;
				ADMUX = admux[i];
				
				ADCSRA |= (1 << ADSC);
				while (ADCSRA & (1 << ADSC));
				adc_output = (ADC >> 6);
				actual_voltage = 1.0 * adc_output / 256;
				
				if((actual_voltage > 2) && (i != currentOff))
				{
					//object crossed laser
					life--;
					score -= 50;
					PORTB = PORTB | 0x02;	//buzzer on
					if(life == 0) 
					{
						break;
					}
				}
			}
			
			if(life == 0)
			{
				display_results();
				break;
			}
			
			wait++;
			score -= 10;	//score decreases with time so that faster maze solving gets you more score
			
			//display current score and number of lives left
			LCD_Clear();
			LCD_GoToLine(0);
			LCD_Printf("life: %d", life);
			LCD_GoToLine(1);
			LCD_Printf("score: %d", score);
			_delay_ms(100);
		}
	}
	return 0;
}

void RTC_values()
{
	//clock will start at 00:00:00
	rtc.hour = 0x00; 
	rtc.min =  0x00;
	rtc.sec =  0x00;

	//random date [doesn't matter what you set]
	rtc.date = 0x01; //1st Jan 2019
	rtc.month = 0x01;
	rtc.year = 0x19;
	rtc.weekDay = 2; // Tuesday: 2nd day of week considering Monday as first day.
}

/*ADC Function Definitions*/
void adc_init(void)
{
	ADCSRA=(1<<ADEN)|(1<<ADSC)|(1<<ADATE)|(1<<ADPS2);
	SFIOR=0x00;
}

int read_adc_channel(unsigned char channel)
{
	int adc_value;
	unsigned char temp;
	ADMUX=(1<<REFS0)|channel;
	_delay_ms(1);
	temp=ADCL;
	adc_value=ADCH;
	adc_value=(adc_value<<8)|temp;
	return adc_value;
}

void display_results()
{
	RTC_GetDateTime(&rtc);	//stop RTC
	LCD_Clear();
	LCD_GoToLine(0);
	LCD_Printf("Game Over");
	
	PORTB = 0x00;	//turn off all the lasers
	_delay_ms(200);
	
	//display final score and time taken to solve maze
	LCD_Clear();
	LCD_GoToLine(0);
	LCD_Printf("score: %d", score);
	LCD_GoToLine(1);
	LCD_Printf("time: %2x:%2x",(uint16_t)rtc.min,(uint16_t)rtc.sec);
}
